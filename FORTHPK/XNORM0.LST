Гусев Михаил

	    ******  ******   ******  ******  **   *
	    **      **   *   **   *    **    **   *
	    *****   **   *   ******    **    ******
	    **      **   *   ** **     **    **   *
	    **      ******   **  **    **    **   *


		(для более-менее начинающих)

		Описание реализации языка ФОРТ

		================
		Работа со стеком
		================

Глубина стека на момент выхода из данного слова:
: depth ( - a ) ... ;

   Операции со стеком будут описаны символически, причем не играющие
роли значения на стеке будут обозначены буквой "p", за описанием
каждого слова идет пример.

   Копирование верхнего элемента стека:
: dup  ( p,a - p,a,a ) ... ;
Ваш ход: 1 2 dup . . .
Ответ  : 2 2 1

   Удаление верхнего элемента стека:
: drop ( p,a - p ) ... ;
Ваш ход: 1 2 3 drop . .
Ответ  : 2 1

   Копировать элемент лежащий под верхним:
: over ( p,a,b - p,a,b,a ) ... ;
Ваш ход: 1 2 3 over . . . .
Ответ  : 2 3 2 1

   Переставить два элемента стека:
: swap ( p,a,b - p,b,a ) ... ;
Ваш ход: 1 2 . .
Ответ  : 2 1
Выш ход: 1 2 swap . .
Ответ  : 1 2

   Скопировать верхний элемент стека, если он не ноль:
: ?dup ( p,a - p,a,a  если a<>0      или        p,a  если a=0 )  ... ;
Ваш ход: 1 ?dup 0 ?dup 2 ?dup . . . . .
Ответ  : 2 2 0 1 1

   Крутануть три верхних элемента стека так, что самый нижний элемент
станет самым верхним:
: rot  ( p,a,b,c - p,b,c,a ) ... ;
Ваш ход: 1 2 3 . . .
Ответ  : 3 2 1
Ваш ход: 1 2 3 rot
Ответ  : 1 3 2
Ваш ход: 1 2 3 rot rot
Ответ  : 2 1 3

   Крутануть три верхних элемента стека так, что самый верхний элемент
становится на место самого нижнего:
: -rot ( p,a,b,c - p,c,a,b ) ... ;
Ваш ход: 1 2 . .
Ответ  : 2 1
Ваш ход: 1 2 3 -rot . . .
Ответ  : 2 1 3

   Удалить элемент лежащий под самым верхним, эквивалентно "swap drop":
: press ( p,a,b - p,b ) ... ;
Ваш ход: 1 2 3 . . .
Ответ  : 3 2 1
Ваш ход: 1 2 3 press . .
Ответ  : 3 1


    Следует заметить, что Форт является целочисленным языком, конечно
имеется возможность создания слов, работающих с числами с плавающей
точкой, но это громоздко и неудобно. То есть если вы хотите работать с
плавающей запятой, то используйте Бейсик, Си или Паскаль (или даже
Фокал :-) . В Форте используются 2-х байтное и 4-х байтное
представление целых чисел, соответственно: целые числа одинарной и
двойной длинны. Причем Форт не знает что именно лежит на стеке,
ответственность за это лежит на вас. Чтобы ввести число двойной длинны
надо поставить в любом его месте точку. Например: " 123. " . Старшая
часть числа лежит на стеке сверху. По этому для преобразования
двойного числа в одинарное надо просто выполнить слово "drop".


"over,"dup,"drop,"swap - Работа с числами двойной длинны

   Чтение n-ого элемента стека данных:
: pick ( a[n],...,a[0],n - a[n],...,a[0],a[n] ) ... ;
Ваш ход: 4 3 2 1 0 2 pick . . . . . .
Ответ  : 2 0 1 2 3 4
Ваш ход: 4 3 2 1 0 4 pick . . . . . .
Ответ  : 4 0 1 2 3 4


   Прочитать указатель стека данных:
: sp@ ( - s ) ;


Записать указатель стека данных, сдесь несколько некорректно
записывать то, что останется на стеке, так как изменяется
сам указатель стека:
: sp! ( s - ) ;


Распечатать содержимое стека начиная с вершины (для некоторых слов
будет описана их примерная реализация на языке Форт, которая может
быть пока непонятной для незнатоков, но чем дальше в лес, тем больше
дров)
: s. ( ) depth  0 ?do i pick . loop ;


Операции со стеком возвратов представляют большую свободу при
манипулировании со стеком данных, плюс доступ к контексту вызова и
его изменение, значения на стеке возвратов будем обозначать в
квадратных скобках:
: >r    ( p,a [p] - p [p,a] ) ... ;
: r>    ( p [p,a] - p,a [p] ... ;
: r@    ( p [p,a] - p,a [p,a] ... ;
: rdrop ( p [p,a] - p [p] ) ... ;
: rpick ( p,n [an,...,a0] - p,an [an,...,a0] ) ... ;
: r=	dup >r ;

	Хочеться отметить, что данные слова играют большую роль в
Форт системе и при умелов обращении могут намного упростить вашу работу
со стеком и управление ходом выполнения шитого кода. Причем словo r= является
нестандартным, как и многие слова этой реализации.


   Теперь поговорим о переменных, адресах, пересылках ...
   Для создания переменной в стандартном Форте требовалось бы ввести
следующую последовательность символов (этот способ работает и в данной
реализации):
			variable total

   После этого при исполнении слова "total" на стеке остается адрес
ячейки памяти выделенной под эту переменную:

		( ) total ( address )

   Для создания массива используется команда "region", которая создает
слово, которое после своего исполнения оставляет на стеке адрес ячейки
памяти, следующей за определением слова, но память выделять нужно уже
вам. (немножко запутанно, но примеры ясные и понятные):

		region array  1000 allot

   В примере мы создаем массив длинной в 1000 байтов и как нетрудно
догадаться слово "allot" резервирует указанное количество байт. Тут
нужно упомянуть, что все слова Форта связаны в словарь, который растет
в сторону больших адресов. Каждое новое слово добавляется в его конец,
и удаление слова в середине словаря возможно только при совместном
удалении всех слов позже созданных. Слово "," - запятая, берет число
со стека данных и кладет его на словарь (имеется анология со стеком,
но словарь в основном растет, мы редко будем с него что-нибудь
убирать)

: variable 	region 0 , ;

   Следует указать, что слова "variable", "region" являются
определяющими, в том смысле, что они сами определяют(создают) новые
слова имена которых берутся из входного потока. В приведенном выше
описании слова "variable" мы видим использование слова "region".

"variable - создает переменную двойной длинны.

: "variable	region 0 , 0 , ;


   Видимо необходимо еще раз указать на отличие этой форт системы от
остальных некоторой нестандартностью создания полей кода и полей параметров,
в этой реализации они "перемешаны". И по этому слово create , в стандартном
форте создающее слово, которое является исполняемым, в данной версии создает
только поля имени, связи и флагов, и прямо может использоваться, например,
для создания подпрограмм в кодах, точнее говоря начинающихся с кодов, так как
в данной реализации переход от шитого кода к кодам максимально упрощен, и
об этом более подробно будет рассказано в пособии для более продвинутых.

=====================
  Работа с адресами
=====================

Переместить область памяти пословно:
: move ( откуда,куда,сколько-слов - ) ... ;

Переместить область памяти побайтно:
: cmove ( откуда,куда,сколько-байт - ) ... ;

Заполнить область памяти словом:
: fill ( слово,сколько-раз,область - ) ... ;

Заполнить область памяти байтом:
: cfill ( байт,сколько-раз,область - ) ... ;

Считать слово (дв.слово) по адресу, слово двойной длинны располагается
следующим образом, на стеке сверху лежит старшее слово, а под ним
младшее; в памяти сначала лежит младшее слово, а за ним старшее.
: @ ( адрес - содержимое ) ... ;
: "@ ( адрес - дв.содержимое ) ... ;

Записать слово (дв.слово) по адресу:
: ! ( слово,адрес - ) ... ;
: "! ( дв.слово,адрес - ) ... ;

Прибавить по адресу:
: +! ( слагаемое,адрес - ) ... ;
: "+! ( дв.слагаемое,адрес - ) ... ;

Вычесть по адресу:
: -! ( вычитаемое,адрес - ) ... ;
: "-! ( дв.вычитаемое,адрес - ) ... ;

Прибавить 1 по адресу:
: 1+! ( адрес - ) ... ;
: "1+! ( адрес - ) ... ;

Вычесть единицу по адресу:
: 1-! ( адрес - ) ... ;
: "1-! ( адрес - ) ... ;

Переслать ноль по адресу:
: 0! ( адрес - ) ... ;
: "0! ( адрес - ) ... ;

Заслать единицу по адресу:
: 1! ( адрес - ) ... ;

Считать байт по адресу:
: c@ ( адрес - байт ) ... ;

Записать байт по адресу:
: c1 ( байт,адрес - ) ... ;

Вывести содержимое по адресу:
: ? ( адрес - ) @ u. ;

Пример:

region a 1 ,
region b 2 ,
region c 0 ,

( Слово складывает содержимое переменных a и b, помещает сумму в )
(  переменную c 						 )
: compute
	a @	( a )
	b @	( a,b )
	+	( a+b )
	c	( a+b,&c )
	!
;


   Теперь я думаю, вы немного познакомились с основами языка Форт,
разве что только не запомнили некоторых слов и некоторых еще не
знаете, но их описание вы можете найти в приложении. Дальше в основном
будут идти примеры по типу: Вы хотите сделать ЧТО-ТО -> Программа
делающая это ЧТО-ТО.


   Циклы:

	Цикл со счетчиком:

Ваш ход:	: primer
Ваш ход:		10 0 do
Ваш ход:			i .
Ваш ход:		loop
Ваш ход:	;
Ваш_ход:	primer
Ответ  : 0 1 2 3 4 5 6 7 8 9


	Цикл с предусловием условием:

Ваш_ход:	: пример
Ваш_ход:		begin
Ваш_ход:			?dup
Ваш_ход:		while
Ваш_ход:			2* .
Ваш_ход:		repeat
Ваш_ход:	;
Ваш_ход:	0 1 2 3 4 5 6 7 8 9 10 пример	
Ответ  :	20 18 16 14 12 10 8 6 4 2


	Цикл с постусловием:

Ваш_ход:	: пример
Ваш_ход:		begin
Ваш_ход:		dup .
Ваш_ход:		1-
Ваш_ход:		dup
Ваш_ход:		7 =
Ваш_ход:		until
Ваш_ход:		drop
Ваш_ход:	;
Ваш_ход:	10 пример
Ответ  :	10 9 8
Ваш_ход:	15 пример
Ответ  :	15 14 13 12 11 10 9 8


    А вообще то по всем управляющим словам данная реализация Форта
совместима со стандартами.




	------------------------------------------------
	Далее идет описание слов, содержащихся в словаре
	на данный момент.
	------------------------------------------------



			============
			  Графика:
			============
Картинка имеет формат:
0 - размер в словах по X (одно слово-по 8 точек для каждого плана,1 и 2-го)
2 - размер в строках по Y
4 - картинка ...
    ........

Имеется слово, которое определяет имя и размер для картинки:
: defpic ( dx dy ) region swap , , ;

Для вывода картинки на экран имеется слово:
: putpic ( x y pic ) .... ;
,где x - координата по X от 0 до 79 (дес)
     y - координата по y от 0 до 263 (дес)
   pic - адрес начала картинки в памяти.

Пример:

octal
1 10 defpic picture	( определим картинку "picture" размером 1 на 8)
( зададим данные для картинки )
1234 ,
23214 ,
46442 ,
345 ,
1 , 45 , 576 , 234 , ( ... )
40 100 picture putpic	(  выведем картинку )



   Установить окно вывода и центр координат:
: xyxyab ( x1,y1,x2,y2,a,b ) ... ;


Экран(см.ниже), $-центр координат, Причем отсчет x1,x2,y1,y2 ведется
от начала экрана, а не от точки (a,b).
   ...............A
   .+-------------!------------------+
   .|  (x1,y1)    .                  !
   .!      ================          !
   B-......#......$       #          !
    !      #              #          !
    !      #              #          !
    !      ================(x2,y2)   !
    +--------------------------------+

   Можно выводить и точками, в четырех цветном режиме, используя
возможность доступа к планам памяти 1 и 2 и центрального процессора.
В данном слове присутствует проверка границ, устанавливаемая словом
xyxyab, а так как pset пользуются и line, и circle, то проверка
работает и у них.
: pset ( x,y,color- ) ... ;

   Провести линию:
: line ( x1,y1,x2,y2,color - ) ... ;

   Нарисовать окружность:
: circle ( x,y,radius,color - ) ... ;

Установить маштабирование окружности по осям относительно центра,
новые координаты относительно центра задаются так: x'=x*a/b, y'=y*c/d
где операции умножения и деления выполняются последовательно, являются
целочисленными и промежуточный результат может быть двойной длинны:
: mxmy ( a,b,c,d - ) ... ;

   Так же добавлено слово для вывода на экран картинок с точностью до
одной точки: "putmsk". Все входные параметры аналогичны слову
"putpic", только x- интерпретируется не как номер октета точек, а как
номер точки.


			============
			  Оверлеи:
			============

Оверлей - уже скомпилированная часть программы, записанная в отдельный
файл, при загрузке не требует времени на компиляцию. Но может быть
загружен только с того места из которого был выгружен. При выгрузке
оверлея он не удаляется из памяти.

Ввод/вывод оверлеев ведется по 7-му каналу. Следовательно не надо
его занимать. Буфер ввода/вывода для оверлея начинается с 2400 и
не пересекается с буфером ввода из файла текста программы, следовательно
с оверлеями можно работать при вводе программы из файла.

Структура оверлея:
0 - Адрес с которого будет загружаться оверлей.
2 - Длинна выгруженной части в байтах
4 - nfa для последнего слова в словаре
6 - Вершина словаря с оверлеем
10 - ....

Выгрузка оверлея из режима исполнения:
putovr куда-выгружать с-какого-слова начинать
		или
Выгрузка оверлея из скомпилированного слова, имя файла
для канала 7 надо установить заранее:
адрес-строки-с-именем-слова (putovr) 

Загрузка оверлея из режима исполнения:
getovr имя-файла
		или
Выгрузка из скомпилированного слова, при условии, что
установлено имя файла для 7 канала:
(getovr)

			=====================
			  Работа с файлами:
			=====================

добавка: везде  где о работе с файлами указано  обращение по  нулевому
каналу, на самом деле происходит обращение по каналу, заданному переменной
inch, в которой лежит номер  канала, по которому сейчас происходит загрузка
или -1, если идет ввод с клавы,так же см. переменную iodir, и теперь возможна
вложенная загрузка  с помощью команды &, сначала  идет загрузка по нулевому
каналу,  затем по первому ... , учтите, что овелеи загружаюся, выгружаются
по 7 каналу.


Многие слова кладут о наличии ошибки на стек, error=0 - ошибка;
Причем, если необходимо получить код этой ошибки, надо прочитать
содержимое байта по адресу 52:  52 c@

Чтение байта из входного потока (файл(канал0) или клавиатура):
: gtbyte ( - c) ... ;


С помощью этого слова легко реализвать свои символы комментария,
например двойной минус: "--":

: -- begin gtbyte 15 = until ;	-- Это комментарий, который идет
				-- до конца строки.

Чтение байта с клавиатуры при помощи системного запроса .TTYIN
: key ( - c) ... ;

Переназначение ввода на файл при условии, что имя файла
для канала 0, уже установлено, так как слово использует
нулевой канал для открытия файла данных.
: load ( ) ... ; 

Вывод байта на канал:
: &putbyte ( byte,chan - error ) ... ;

Чтение байта с канала:
: &getbyte ( chan - byte,error ) ... ;

Закрыть канал:
: &close ( chan - error ) ... ;

Закрыть канал, не создавая файла:
: &purge ( chan - error ) ... ;

Записать буфер по каналу:
: &writeblock ( chan - error ) ... ;

Считать буфер по каналу:
: &readblock ( chan - error ) ... ;

Открыть на запись:
: &enter ( chan - error ) ... ;

Открыть на чтение, возвращает длинну файла или ноль, если ошибка
: &lookup ( chan - length or 0 if not found ) ... ;

Установить блок:
: &block ( chan,block - ) ... ;

Установить буфер, минимальный размер 512 байт :
: &buffer ( chan,buffer - ) ... ;

Переназначить ввод на файл, имя берется из входного потока:
& имя-файла

На входе адрес строки на выходе адрес строки длинной 6 символов,
дополненной пробелами или усеченной, исходная строка неизменна:
: len6 ( adr-adr' ) ... ;

Установить имя файла, задаваемое строкой, для канала:
: &file ( chan,adr-error ) ... ;

Получить адрес параметров канала:
: &cdata ( chan-adr ) ... ;
0 - ИМЯ
2 -  ФАЙЛА
4 -   В
6 -    RADIX50
10 - буфер
12 - счетчик
14 - 
16 - блок

Если error=0, то выдается сообщение об ошибке i/o и abort.
: erio? ( error - ) ... ;


Остов для работы с файлами:

region input-buffer 1000 allot	-- входной буфер
region output-buffer 1000 allot -- выходной буфер
1 constant inch			-- номер входного канала
2 constant outch		-- номер выходного канала

: open
	-- открытие входного файла --
	inch bl word &file error" Неправильное имя входного файла"
	inch &lookup error" Файл не найден"
	inch input-buffer &buffer

	-- открытие выходного файла --
	outch bl word &file error" Неправильное имя выходного файла"
	outch &enter error" Ошибка создания файла"
	outch output-buffer &buffer
;

: get	( - считанный-символ)
	inch &getbyte error" Ошибка чтения"
;

: put	( выводимый-символ - )
	outch &putchar error" Ошибка записи"
;

Причем имена входного и выходного файлов берутся из входного потока
символов.


		========================
		  Переназначить вывод:  
		========================

Адрес регистра состояния стандартного вывода лежит в константе:
ttycsr

Адрес регистра данных std вывода лежит в константе:
ttydat

Если в ttycsr лежит отрицательное число, то оно воспринимается, как
адрес, и вывод происходит по регистрам ttycsr,ttydat.
Если в ttycsr лежит положительное число, то оно воспринимается, как
номер канала, и вывод будет происходить по каналу, который необходимо
предварительно открыть на вывод. Если при выводе возникнет ошибка, то
возникнет сообщение об ошибке, а файл будет потерян.

Стандартный вывод на экран (через регистры терминала):
: stdtty 177564 to ttycsr 177566 to ttydat ;

Стандартный вывод на принтер (через регистры принтера):
: lpctty 176664 to ttycsr 176666 to ttydat ;

Стадтартный вывод на канал (по номеру канала):
: chntty ( chan - ) to ttycsr ;


Переназначение вывода, как и ввода по команде "load", очень удобно,
так как написав программу, работающую с данными вводимыми с клавиатуры
и результатами выводимыми на экран, отладив ее (в диалоговом режиме, а
еще и при наличии встроенного отладчика это гораздо удобнее), можно
очень быстро, надстроив всего только оджно слово, переделать программу
для работы с файлами.






Инициализация системы, устанавливает стеки, закрывает каналы,
устанавливает систему счисления base0, устанавливает стандартный
вывод на экран, устанавливает ст.ввод на клавиатуру, устанавливает
режим интерпретации, (*) вывести стартовое сообщение, вызвать
интерпретатор. Звездочкой помечено место адрес которого возвращается
после вызова слова entryptr, и туда можно занести свое стартовое слово.
: initialize  ... ;

Возврат из вставки шитого кода в ассемблер. Пример, поставить точку
по координатам (100,200) цвет вводится через стек, на который всегда
указывает регистр r5, при исполнении шитого кода на него указывает
регистр r4:	next:	rts	r4
create primer
	12500 ,			(	mov	{r5}+,r0	)
	12745 , 100 ,		(	mov	#100,-{r5}	)
	12745 , 200 ,		(	mov	#200,-{r5}	)
	10045 ,			(	mov	r0,-{r5}	)
	4437 ,			(	jsr	r4,@{pc}+	)
	' pset , 		(	.word	pset		)
	' next ,		(	.word	next		)
	. . .				. . .
	134 ,			(	jmp	@{r4}+		)

Получить адрес для замены интерпретатора:
: entryptr ( - adr ) ... ;

Выход без очистки стека данных, уст. стек возвратов, стандартный
вывод на экран, стандартный ввод с клавиатуры, система счисления на
base0, вызов интерпретатора.
: quit ... ;

Выход как quit, только с очисткой стека данных:
: abort ... ;

Завершение выполнения слова в шитом коде (возврат назад):
exit:	mov	(sp)+,r4
	jmp	@(r4)+
Неявно используется при завершении компиляции слова при вызове ';', а
так же может быть использовано самостоятельно. Пример, при выполнении
слова на экран выведется строка текста в случае, если на входе слова
был ноль, Следует заметить, что в круглых скобках заключаются комментарии
которые часто показывают состояние стека, обычно после начала определения
слова, которое использует параметры со стека и/или их возвращает на стек,
описывают в комментарии все входные параметры, потом 'стрелка', потом
все выходные:
: test-if-zero ( 0/1 - ) if exit then ." На стеке лежал ноль" ... ;

Поиск слова в словаре системы, причем имя слова задается строкой,
ограниченной нулем, а на стек кладется адрес этой строки. На выходе
либо 0: слово не найдено, либо cfa: слово найдено, Причем cfa и nfa
слова дополнительно помещаются в однойменные переменные:
( Добавим, что слова в поле флагов которых стоит бит smudge=2,
а так же слова в которых стоит аттрибут name(при условии, что
переменная defence имеет ненулевое значение) , В ПОИСК НЕ
ВКЛЮЧАЮТСЯ, хотя и будут видны при просмотре словаря командами
vlist и words )
: search ( adr - 0/cfa ) ... ;

Начальное сообщение системы:
: smsg ." (c) MGS 1993 PCODE system V2.00" ;

Выход в систему:
: stop ... ;

Вывод списка имеющихся слов 1) в один столбец, 2) на всю ширину:
1) : words ... ;
2) : vlist ... ;

Интерпретатор системы, алгоритм стандартного Форта:
: interpret ... ;

Системы счисления 8,10,16,2 соответственно:
: octal ... ;
: decimal ... ;
: hex ... ;
: bin ... ;

Вывод дампа памяти:
: dump ( адрес,длинна - ) ... ;

Константа: вершина пустого стека данных = 4000
: s0 ( - 4000 ) ... ;

Константа: вершина пустого стека возвратов = 1400
: r0 ( - 1400 ) ... ;

Константа: основание системы по умолчанию, первоначально = 8
: base0 ( - 8 ) ... ;

Переменная: состояние системы =0-интерпретация   /   =1-компиляция:
: state ( - адр ) ... ;

Константы наиболее часто используемых чисел: 0,1,2,3,4,-1,-2,-3,-4

Переменная: вершина словаря:
: h ( - адр ) ... ;

Вершина словаря:
: here ( - указатель ) h @ ;

Переменная: указатель на nfa последнего опр. слова:
: last ( - адр ) ... ;

Переменная: текущая система счисления:
: base ( - адр ) ... ;

Переменная: откуда идет ввод  0=с клавиатуры  /  1=из файла:
: iodir ( - адр ) ... ;

Константы пробела и кавычек:
decimal : bl 32 ;
decimal : quote 34 ;

Переменные: отнсящиеся к последнему слову, искомому с помощью search:
: cfa ( - адр ) ... ; : nfa ( - адр ) ... ;

Переменная: положение десятичной точки в числе, проверенном с помощью
number, если ее нет, то -1:
: dpl ( - адр ) ... ;

Создать массив: Создать имя, которое будет браться из входного потока,
создать исполняющую часть, после исполнения которой на стеке будет
оставаться адрес словаря следующий непосредственно после исполняющей
части, если после определения слова стоят два коментария, первый
говорит о том что делает данное слово, а второй говорит о том, что
делает слово определяемое с помощью данного слова:
: region ( - ) ( - адр ) ... ;
Пример использования:
region массив 100 allot  ( создание массива длинной в 100 байт )
region данные 0 , 0 , 0 , ( создание массива длинной в 6 байт )

Создать переменную одинарной и двойной длинны, двойные кавычки
перед именем слова говорят о том, что это слово, аналогично
слову без кавычек, но используется со словами двойной длинны:
: variable ( - ) ( - адр ) region 0 , ;
: "variable ( - ) ( - адр ) region 0 , 0 , ;

Создать константу одинарной и двойной длинны: создать имя,которое
будет браться из входного потока, запомнить константу со стека. А при
исполнении положить эту константу на стек:
: constant ( конст - ) ( - конст ) ... ;
: " constant ( дв.конст - ) ( - дв.конст ) ... ;

Записать число со стека в константу. Иногда удобно изменять значения
констант, или просто не пользоваться механизмом переменных а работать
только с константами. Чтобы считать число из константы, надо просто
исполнить слово с ее именем, чтобы записать число в константу, надо
положить его на стек, а потом исполнить слово 'to' после которого
следует написать имя константы. Слово 'to' работает, как в режиме
исполнения, так и в режиме компиляции:
: to ( значение - ) ... ;
: "to ( дв.значение - ) ... ;
Пример:
1 constant а	( опр. константы )
2 to а		( изм. ее значение в режиме исполнения )
: b 3 to а ; b	( изм. ее заначение в режиме компиляции )

Сравнение, истина-не ноль  /   ложь - ноль
: 0= 	( a - a=0 ) ... ;
: "0= 	( da - da=0 ) or 0= ;
: 0<> 	( a - a<>0 ) 0= not ;
: "0<> 	( da - da<>0 ) "0= not ;
: =	( a,b - a=b ) - 0= ;
: "=	( da,db - da=db ) "- "0= ;
: <>	( a,b - a<>b ) = not ;
: "<>	( da,db - da<>db ) "= not ;
: 0<	( a - a<0 ) ... ;
: "0<	( da - da<0 ) ... ;
: 0>	( a - a>0 ) negate 0< ;
: "0>	( da - da>0 ) negate "0< ;
: <	( a,b - a<b ) - 0< ;
: "<	( da,db - da<db ) "- "0< ;
: >	( a,b - a>b ) - 0> ;
: ">	( da,db - da>db ) "- "0> ;

Беззнаковое сравнение:
: u>    ( ua,ub - ua>ub ) ... ;
: u<    ( ua,ub - ua<ub ) ... ; 

Арифметические операции:
: +	( a,b - a+b ) ... ;
: "+	( da,db - da+db ) ... ;
: - 	( a,b - a-b ) ... ;
: "-	( da,db - da-db ) ... ;
: negate  ( a - -a ) ... ;
: "negate ( da - -da ) ... ;
: 2*	( a - a*2 ) ... ;
: "2*	( da - da*2 ) ... ;
: 2/	( a - a/2 ) ... ;
: "2/	( da - da/2 ) ... ;
: <<	( a,b - a*2^b ) ... ;
: "<<	( da,b - da*2^b ) ... ;
: *	( a,b - a*b ) ... ;
: /	( a,b - a/b ) ... ;
: /mod	( a,b - a%b,a/b ) ... ;		( a%b - означает остаток )
: mod	( a,b - a%b ) ... ;
: and	( a,b - a and b ) ... ;		( побитно )
: or	( a,b - a or b ) ... ;		( побитно )
: not 	( a - not a ) ... ;		( побитно )
: xor	( a,b - a xor b ) ... ;		( побитно )
: 1+	( a - a+1 ) ... ;
: 1-	( a - a-1 ) ... ;
: 2+	( a - a+2 ) ... ;
: 2-	( a - a-2 ) ... ;
: abs	( a - |a| ) ... ;
: "abs	( da - |da| ) ... ;
: max	( a,b - max{a,b} ) ... ;
: umax	( ua,ub - umax{ua,ub} ) ... ;	( без знаков )
: min	( a,b - min{a,b} ) ... ;
: umin	( ua,ub - umin{ua,ub} ) ... ;	( без знаков )

Перестановка байтов
: swab  ( a - swab a ) ; 

Операция маштабирования, промежуточный результат двойное число.
: */	( a,b,c - a*b/c ) ... ;
: */mod	( a,b,c - {a*b}%c,{a*b}/c ) ... ;
: m*	( a,b - double a*b ) ... ;
: m/	( da,b - c ) ... ;
: um/mod ( da,b - single da%b, single da/b ) ... ;
: m/mod	( da,b - single da%b, double da/b ) ... ;

Преобразовать из одинарного в двойное, с расширением знака:
: s->d ( a - double a ) ... ;

Форматный вывод чисел:
----------------------

Переменная, указатель в pad буфере:
variable hld

Буфер pad, в который будут записываться цифры преобразуемого числа,
размер 50 байт, на стек кладется адрес вершины буфера, указатель
hld будет изменятся в сторону уменьшения:
: pad ( - a ) ... ;

Начать преобразование, причем преобразовываться будет число
двойной длинны:
: <# pad hld ! ;

Конвертировать одну цифру, начиная с младших разрядов, причем
результат помещается в буфер pad:
: # ( da - da/base ) ... ;

Поместить литеру в буфер pad, еще раз следует напомнить, что
заполение буфера pad ведется справа на лево и если в преобразовании
встретится ... c" A hold c" B hold ... , то при выводе окончательного
результата мы получим ...BA...:
: hold ( c - ) hld @ c! hld 1-! ;

Преобразовать число полностью:
: #s ( da - 0. ) begin # "dup "0= until ;

Завершить преобразование, где as-адрес строки, ns-длинна строки:
: #>  ( da - as,ns ) "drop hld @ pad over - swap 1+ swap ;

Положить в pad "-", если a<0:
: sign ( a,b,c - b,c ) rot 0< if c" - hold then ;

Вывести двойное число, выровненное по правому краю:
: ".r ( da,r - ) >r swap over "abs <# #s sign #>
r> over - spaces drop type ;

Вывести одинарное число по правому краю:
: .r ( a,r - ) >r s->d r> ".r ;

Вывести двойное число, невыровненное:
: ". ( da - ) 0 ".r space ;

Вывести одинарное число:
: . ( a - ) реализовано без форматного преобразования ;
: u. ( a - ) ... ;

=====================================
Управление ходом выполнения программы
=====================================
Безусловный переход по адресу, следующему за командой в шитом коде,
используется в стандартных словах, можно делать и свои.
: branch ... ;        .....branch a....... a:

Переход,если на стеке лежит ноль:
: ?branch ( a - ) ... ;   .  .  .

Переход, если на стеке лежит не ноль:
: n?branch ( a - ) ... ;  .  .  .

Реализация завершения цикла со счетчиком,исп.стек возвратов,
прибавляет к счетчику 1 (или число со стека),
если не конец то переход по адресу,
который идет вслед за командой в шитом коде:
: (loop) ... ;           ...(do) a b: ..... (loop) b a: ...
: (+loop) ( a - ) ... ;

Реализация начала цикла со счетчиком:
: (do) ... ;		...(do) a b: ..... (loop) b a: ...
: (?do) ... ;		...(?do) a b: ..... (loop) b a: ...

Получить переменную цикла:
: i ( - a ) ... ;	внутреннего
: j ( - a ) ... ;	внешнего
: k ( - a ) ... ;	еще более внешнего
: ii ( n - a ) ... ;	n-внешности , если 0, то текущего

Покинуть do ... loop цикл:
: leave ... ;

Пометить начало перехода вперед:
: >mark here 0 , exit ;

Пометить начало перехода назад:
: <mark here exit ;

Пометить конец перехода вперед:
: >resolve here swap ! ;

Пометить конец перехода назад:
: <resolve , ;

Различные команды, можно использовать только внутри определений:
Условный оператор:
( p,a ) if ( p ) ................... then ( p )
( p,a ) if ( p ) ... else ( p ) .... then ( p )
( p,a ) ifnot ( p ) ................... then ( p )
( p,a ) ifnot ( p ) ... else ( p ) .... then ( p )

Оператор выбора:
( p,a ) select ( p )
... ( p,c ) case ( p ) ....... ecase ( p )
... ( p,c ) case ( p ) ....... ecase ( p )
... ( p,c1,c2 ) diap ( p ) ... ecase ( p )      Вып.если c1<=a<=c2
..........................................
( p ) eselect ( p )

Оператор цикла со счетчиком:
( p,b,a ) do ( p ) ... leave ... loop ( p )
( p,b,a ) do ( p ) ... leave ... ( p,i ) +loop ( p )
( p,b,a ) ?do ( p ) ... leave ... loop ( p )
( p,b,a ) ?do ( p ) ... leave ... ( p,i ) +loop ( p )

Оператор цикла с условием:
( p ) begin ( p ) ........ ( p,f ) until ( p ) 
( p ) begin ( p ) ... ( p,f ) while ( p ) ... repeat ( p )

Оператор бесконечного цикла:
begin ..... again

==================
Проверка состояний
==================
Если f истина, то ошибка n:
: ?error ( f,n - ) swap branch >mark error >resolve drop exit ;
: ?comp ... ;	- Ошибка, если не компиляция
: ?exec ... ;	- Ошибка, если не исполнение
: ?pairs ( a,b - ) ... ;	- Ошибка, если a<>b

====================
Дополнительные слова
====================
Положить число из шитого кода на стек:
: lit ( - a ) ... ;    ..... lit a ....
: dlit ( - da ) ... ;  ..... lit da ....

Текущий адрес вершины словаря:
: here ( - here ) h @ ;

Зарезервировать на словаре n байт:
: allot h +! ;

Создать слово по имени из стека:
: (create) ( name - ) ... ;

Положить на стек адрес строки скомпилированной в шитом коде:
: (") ( - str ) ... ;     ....(") a STROKA a:.......

Распечатать строку, скомпилированную в шитом коде:
: (.") ... ;		...(.") a STROKA a:.....

Создать имя слова по имени из входного потока:
: create bl word dup search if 4 message then (create) ;

Скомпилировать на словарь число из шитого кода:
: compile ... ;

Положить со стека данных на словарь:
: , ( a - ) here ! 2 h +! ;

Как обойтись с числом лежащем на стеке, в зависимости
от режима (компиляция или исполнение):
: literal state @ if compile lit , then ;
: dliteral state @ if compile dlit , , then ;

Поставить последнему созданному слову флаг
немедленности исполнения:
: immediate ... ;

Перейти от адреса кода к адресу имени:
: >name ( cfa - nfa ) ... ;

И наоборот:
: name> ( nfa - cfa ) ... ;

Начать создающую часть создающего слова:
: <build create ... ;

Закончить создающую и начать исполняемую часть создающего слова:
: does> ... ;

Перейти в режим интерпретации:
: [ state 0! ; immediate

Перейти в режим компиляции:
: ] state 1! ;

Выполнить действия по запоминанию литеры, как для числа:
: c" ( ... ) bl word c@ literal ; immediate

Искать слово из вх. потока, и если нет дать ошибку:
: ' ( - a ) bl word search ?dup 0= 0 ?error ;

Искать слово из вх. потока, и запомнить как для числа, см. c":
: ['] ' literal ; immediate

Начать создание слова:
: : ?exec create ] 4437 , ;

Завершить создание слова:
: ; compile exit [compile] [ ;

Вывести строку из определения:
: ........ ." STROKA" ......... ;

Положить на стек адрес строки из определения:
: ......... " STORKA" ( STR ) .... ;

Положить строку на словарь:
: ", ( str - ) ... ;            ..... a STROKA a: ....

Следующее за [compile] слово клад. на словарь:
: [compile] ' , ; immediate

Забыть слово и все следующие за ним:
: (forget) ( name - ) ... ;
: forget bl word (forget) ;



========
Отладчик
========
Жучок:
: (bug) ..;

Включить жучока в начало всех определений
создаваемых по ":"
: bugon .. ;

Выключить постановку жучка:
: bugoff ..;

Команды:
<cr>	- продолжить исполнение
i	- вызов интерпретатора (можно несколько раз вкладывать вызов
	  и интерпретатора и отладчика) (а где запятые а?)
	  (там-то и там-то)
r	- уйти в систему
v	- vlist
s	- s.
n	- не отлаживать больше это слово
q	- отключить отладчик насовсем




Недавно добавювленные слова:


Работа с сопрограммами:
: crtn ... ; Вызов
: crt1 ... ; сопрпограмм
: crt2 ... ; (всего сделано 3 дорожки переключения, хотите делайте больше)

: crtn= ... ; Статическое задание сопрограммы
: crt1= ... ; (статическое-в том смысле, что в данном месте мы
: crt2= ... ; всегда будем задавать именно эту сопрограмму)

: =crtn ... ; Динавическое задание сопрограммы
: =crt1 ... ;
: =crt2 ... ;

Пример:

-- Статическое присваивание

: coprogram-input
	0
	begin
	1+ dup >c crtn
	again ;

: coprogram-work
	begin
	c1> 1+ >c1 crt1
	c1> 2+ >c1 crt1
	c1> 3+ >c1 crt1
	again
;

: coprogram-output
	begin
	c2> . crt2
	c2> dup . . crt2
	again
;

: using
	crtn= coprogram-input
	crt1= coprogram-work
	crt2= coprogram-output
	100 0 do
	crtn crt1 crt2
	loop
;


Пример динамического использование сопрограмм:
в котором используются слова: { и }


: dynamic	( mode- )
	select
	0 case	{ .... } ecase
	1 case	{ .... } ecase
	2 case	{ .... } ecase
	." Не могу" abort
	eselect
	=crtn
;



Слова для задания блоков кода. Блоки кода будут характеризоваться
адресом исполнения. Блоки кода задаются только внутри определений.

: тестирование
	{ ." Test Test" }
	dup
	execute
	execute
;



Введены слова для пропуска некоторых слов при поиске:

: smudge ... ;	Включает/выключает для последнего созданного заголовка
		слова, бит пропуска при поиске

Пример, переопределим оператор деления так, чтобы он
выдавал сообщение при попытке деления на ноль:

: /
	?dup ifnot
		." Деление на ноль" abort
	then

	smudge		-- если пропустить это слово
			-- то в вызывая ниже "/", мы вызвали бы
			-- сами себя, кстати в форте можно делать
			-- рекурсию.

	/		-- вызываем старое определение

	smudge		-- опять включаем поиск
;

Дело в том, что в стандартном Форте smudge реализован несколько
по другому в смысле алгоритма работы: так он не изменяет флаг,
а просто его устанавливает, сброс, же , флага происходит при
завершении слова по точке с запятой, а так как мы можем иногда и
не завершать ввод слова по точке с запятой, например при написании
кисочков программы в машинных кодах, то smudge был реализован как
простой переключатель.

: setname ... ;	Устанавливает в поле флагов последнего созданного
		заголовка слова флаг set-name=4, он ничего не значит,
		пока значение переменной defence равно нулю, если же
		ее значение отлично от нуля, то жтот флаг означает тоже
		самое, что и smudge.


Добавлены операции работы со строками:

Скопировать строку в прямом направлении
: cpystr	( a,b -)
	over len 1+ cmove
;


Расширенное сравнение строк
: extstr	( a,b - f)
	...
;

f =  0 - строки равны
  =  1 - первая строка содержится во второй
  =  2 - вторая строка содержится в первой
  = -1 - строки неравны



Простое сравнение строк
: cmpstr	( a,b - f)
	...
;
f = -1 - строки равны
  =  0 - строки неравны



Сопоставление с шаблоном
: patmat	( s,p - f)
	...
;

В шаблон можно включать следующие знаки: *,?



Перевести строку в верхний ресистр
: toupper	( s-)
	...
;


Найти символ в строке
: finsym	( b,s-s')
	...
;
Если символ найден, то возвращается адрес строки, после него, иначе
возвращается сходный адрес строки. Используется при отсечении
ненужных частей строки. Например надо из полного адреса FIDO
получить адрес сети:

: trx	( adres-net)	c" : finsym 0 over c" / finsym 1- c! ;
: test	" 2:5021/11.2" trx type ;
test
При этом на экране получим: 5021


Найти строку во входном потоке( макс. длинна строки = 64).
: finstr	( s-)
	...
;
Ищется строка во входном потоке, может использоваться во
многих приложениях, так:
а) создание блоков условной компиляции
б) поиск ключевых слов


Ввести строку в формате:    /строка/,  где / - ограничитель, может
быть любым символом, кроме пробела,ГТ,ПФ,ПС,ВК, которые пропускаются
перед вводимой строкой:

: expect ( строка,макс.длинна-строки - )
	...
;



А также добавлены слова для получения различного типа остатков,
так если на строку:::: -7 3 mod .
получим>>>> -1
а на строку::::        -7 3 umod .
получим>>>> 2

так добавлены: umod,*/umod,um*/umod

                                                                                 