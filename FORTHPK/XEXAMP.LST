( Данный файл является закоментаренным описанием + тексты примеров )
( Вы можете его просто загрузить командой "& xxco.lst"             )

decimal	( Устанавливаем десятичную систему счисления, так как при
	начальном запуске системы устанавливается восьмеричная система
	счисления, как более удобная при работе с адресами и
	архитектурой машины, а так же при работе с маш. кодами,
	которые в десятичном исполнении запомнить невозможно.
	)

: c begin gtbyte 10 = until ;	immediate ( Различные варианты комментариев)
: -- [compile] c ;		immediate ( Для удобства чтения 	   )

c    В данную реализацию языка Форт вставлены нестандартные слова
c слова, которые, я надеюсь облегчат вам работу настолько,
c насколько это возможно. 
c
c Расширеный оператор выбора:
c 
c select
c 	...
c 	case ... ecase
c 	...
c 	diap ... ecase
c 	...
c 	true ... ecase
c 	...
c eselect
c 
c И в любом месте может встретится слово "selector", которое
c оставляет после себя на стеке значение ключа по которому происходит
c выбор.
c 




c К примеру вам надо по номеру дня назвать его имя.
c Конечно это можно сделать и другими способами, но это всего лишь
c пример, который позволит вам ощутить мощность этого слова.


: day1	( n-)
	select
		1 5 diap ." Рабочий день: "
			selector select
				1 case ." Понедельник "	ecase
				2 case ." Вторник "	ecase
				3 case ." Среда "	ecase
				4 case ." Четверг "	ecase
				5 case ." Пятница "	ecase
			eselect
		ecase
		6 7 diap ." Воскресный день: "
			selector select
				6 case ." Суббота "	ecase
				7 case ." Воскресенье "	ecase
			eselect
		ecase
		." Не знаю я такого дня недели: " selector .
	eselect
	cr
;
	
.( Пример работы управляющей структуры: select ) cr

0 day1
1 day1
2 day1
3 day1
4 day1
5 day1
6 day1
7 day1
9 day1
10 day1

cr cr cr cr
forget day1



c Теперь посмотрим, что у нас есть для программеров, которые не хотят
c особо чутко следить за состоянием стека данных, стека возврата, а
c также при создании программ с аварийными выходами.

c Во первых: мы можем пометить любое слово "mark=",
c 	а затем вернутся к нему из любого места программы, выполнив
c	команду "back", причем команда "back" является обезличенной,
c	т.е. ей мы можем вызвать слово, которое будет определено
c	гораздо позже. Это удобно при создании интерфейса с
c	пользователем, например системы меню.
c
c ( на самом деле имеются три команды mark= & три команды back
c ими мы можем пометить три разных места )
c 
c Следует упоминуть, что при выполнении слова "back" мы не только
c осуществляем переход к помеченному слову, мы также восстанавливаем
c контекст программы так-же запомненный при выполнении команды "mark=".
c


region what 0 ,

: aaa
	." Subroutine A" cr 
	what @ 0 = if back then		-- переход к помеченному
;


: bbb
	." Subroutine B" cr 
	what @ 1 = if back then
;


: ccc
	." Subroutine C" cr
	what @ 2 = if back then
;

: mark-error
	." Error" cr
;

: show-mark
	mark= mark-error
	4 0 do
		i what !
		aaa
		bbb
		ccc
	loop
;

.( Пример использования точек возврата )
show-mark

cr cr cr cr
forget what


c Так же очень удобным с моей точки зрения является наличие механизма
c переключения контекстов (круто), а проще говоря сопрограмм.
c Правда при этом могут возникнуть накладки при очень глубоком
c использовании стеков данных и стека возвратов, так как они делятся
c при этом примерно на три части и соответственно размер стека,
c доступный одной сопрограмме уменьшается.
c
c Помечаем сопрограмму командой "crtn=", а обращаемся командой "crtn".
c Так же можно перекидывать туда-сюда числа со стеков данных одной и
c другой сопрограммы. При этом не следует забывать про то, что
c сопрограммы ориентированные на получение данных в некоторых случаях
c следует инициализировать.

c Приведем пример использования сопрограмм при написании всяких
c преобразователей (конверторов, архиваторов ... графических форматов )

c К примеру, данные записаны в виде блоков, которые содержат
c в начале счетчик количества записей в блоке. Так как мы говорим о
c сопрограммах, то мешать сюда работу с файлами мы не будем, а просто
c сыммитируем посылку символов. Причем запись будет состоять из
c двух байт, количества повторений символа, и самого кода символа.
c В принципе это можно сделать и без сопрограмм, но так будет проще.
c Давайте усложним задачу тем, что, если счетчик повторений будет
c равен нулю, то символа за ним не последует.


-- Сопрограммка --
: convertor
	-- цикл по блокам --
	begin
		-- цикл по записям --
		crtn c> 0 ?do
			crtn c> ?dup if
				-- цикл по символу --
				crtn c> swap 0 do
					dup emit
				loop
				drop
			then
		loop
	again
;


-- инициализация сопрограммы
: init-co
		crtn= convertor
		crtn
;


.( Пример работы сопрограмм:)  cr

init-co

.( -- first block --) cr
.( -- 5 records   --) cr
5 crtn
	1 crtn c" A crtn
	2 crtn c" B crtn
	3 crtn c" C crtn
	4 crtn c" D crtn
	0 crtn			-- blank record
cr
cr
.( -- second block --) cr
.( -- 3 records    --) cr
3 crtn
	6 crtn c" # crtn
	3 crtn c" $ crtn
	1 crtn c" ! crtn

cr cr cr cr
forget convertor


c А теперь немного поработаем с файлами.
c Напишем слово, построитель программы, которая записывается в файл, а
c затем будем этот файл динамически интерпретировать, как поток Форт команд.
c Ну как, круто?
c Хочется сразу заметить, что перенаправление вывода можно сделать
c в канал с любым номером, а перенаправление ввода действует только
c с канала номер 0.
c К сожалению, этот пример будет последним в данном файле-справичнике,
c так как перенаправив ввод на другой файл мы тем самым лишаем
c себя возможности вновь вернутся к интерпретации данного файла, хотя
c в принципе это возможно, но с некоторыми изворотами, и сдесь,
c ограничиваясь рамками демонстрационного показа, их применять не стоит.
c Но стоит еще добавить, что это не является ограничением, так как
c оно действует только при загрузке исходной программы, и после того
c как она загружена, мы можем перенаправлять ........
c Нет давайте уж покажем эти все извороты, в которые можно воткнуть
c еще пару приемов работы !!!!!

-- Сперва зададим выходной буфер
-- Заметим, что если вы используете переназначение ввода, то
-- по команде "load" входной файл автоматически открывается
-- и ему устанавливается буфер начиная с ячейки 1400(восьмеричное)
octal
region output-buffer 1000 allot
decimal

-- Будем считать, что входной канал - нулевой
-- а выходной - первый.


-- Так можно по ошибке выходить в требуемое вам слово
-- Данное слово получает флаг и адрес строки, если
-- флаг=ошибка, то печатаем на экране строку и переходим
-- на помеченное слово (вот и пригодилось)
: test-error	( flag,string-)
	swap ifnot
		type
		back	-- back to the mark= words
	then
	drop		-- drop string
;


-- Открыть выходной файл...
: open-output
	1 " TEST.DAT" &file " Странно" test-error
	1 &enter " TEST.DAT не создается" test-error
	1 output-buffer &buffer
;

-- Вывести в него требуемую информацию
: put-output
	-- Далее идет текст программы, который мы выведем в файл
	-- а потом динамически загрузим, выполним, и после всего
	-- этого опять будем продолжать загружать данный файл-тест
	-- Хотя это довольно просто, давайте выведем текст программы
	-- Сначала на экран, а затем в файл, одними же и теми
	-- операторами, просто выполним их дава раза.

	2 0 do		-- цикл, который выполнится два раза
			-- в первом разе - вывод на экран
			-- во втором разе - вывод в файл
		."

			.( Загружаем тестирующую программу )
			decimal
			: squares
				21 0 do
					i i * .
				loop
			;
			.( Исполняем эту тестирующию программу )
			squares

			exit	-- если, мы вызвали из форт слова
				-- интерпретатор('interpret'), то
				-- вернуться обратно в вызвавшее слово
				-- можно как рах выволнив команду 'exit'.
		"

		1 chntty	-- переназначение вывода
				-- после этой команды весь терминальный вывод
				-- будет сливаться в файл, открытый по
				-- указанному каналу.
	loop
	1000 0 do 0 emit loop	-- заполнение оставшегося места в блоке
				-- нулями, если этого не делать с каждым
				-- закрываемым файлом, то один последний
				-- блок в 511 из 512 случаев будет потерян.

	stdtty			-- стандартный вывод на экран

	1 &close " Не могу закрыть выходной файл" test-error
;


-- Переменные для алгоритма поиска строки во входном потоке
region $S 0 ,		-- адрес строки
region $L 0 ,		-- длинна строки
region $B 100 allot	-- буфер, куда читаем входную информацию

-- Данное слово выполняет функцию поиска во входном потоке строки
-- адрес строки кладется на стек. В принципе все можно описать на
-- Форте без применения ассемблера, но мне просто хотелось
-- подчеркнуть возможность реализации кусочков программы на ассемблере,
-- иногда это бывает оправдано меньшим временем исполнения, или
-- меньшим объемом кода (допустим при применении какой-либо
-- сложной адрессации, выполнения системной функции, которая
-- отсутствует в Форт словаре ...)

-- Найти строку вида
: find-eq-s ( sting-)
-- 1. находим длинну строки -> #дл
-- 2. загружаем в буффер #дл байтов
-- 3. сравниваем, если равно, то конец работы
-- 4. сдвигаем буффер на один байт
-- 5. считываем еще один байт информации
-- 6. перейти на 3.
	dup $S ! len dup $L !			-- 1.
	0 do gtbyte $B i + c! loop		-- 2.
	begin
		$S @ $B $L @			-- 3.
		next [
		octal
		12500 , 	-- r0=длинна строки
		12501 , 	-- r1=строка1
		12502 , 	-- r2=строка2
		122122 , 	-- сравнение *r1++==*r2++
		1002 ,		-- если не равны, то на 4437
		77003 ,		-- конец цикла по длинне
		134 ,		-- выход на предыдущий уровень
		4437 ,
		decimal ]
	$B dup 1+ swap $L @ 1- dup >r cmove	-- 4.
	gtbyte $B r> + c!			-- 5.
	again					-- 6.
;

-- Причем, предыдущее слово мы закончили открывающейся скобкой
-- а не точкой с запятой, эта хитрость заключается в том, что
-- выход из слова происходит не в конце, как обычно, а в середине слова
-- и по этому нам вовсе не нужен лишний скомпилированный код выхода
-- из слова, после again, мы просто переходим из режима компиляции в
-- режим интерпретации.


-- Слово, осуществляющее обратный возврат на в этом вот самом файле
: backing
	0 &close drop	-- закрыли нулевой канал
	0 " XXCO.LST" &file error" Неправильное имя файла"
	load		-- теперь будем обратно читать сами себя
	" BACK-TO" dup find-eq-s		-- дошли до данной строки
			      find-eq-s		-- дошли до нужной строки
	-- продолжим интерпретацию
;


-- Это слово все и вызывает
: outputing-inputing
	mark= backing
	open-output
	put-output
	0 &close drop		-- закрываем текущий ввод
	0 " TEST.DAT" &file " Не могу открыть на чтение" test-error
	load
	interpret
	cr ." Вернулись после выполнения TEST.DAT" cr
	back
;

cr cr cr cr
.( Процесс пошел, не дышать ... )
outputing-inputing

BACK-TO

-- все сюда мы вернемся и перво-наперво забудем все только что скомпили-
-- рованное, ухх...
-- И как это в голову такие примеры приходят?.. Незнаю...

forget output-buffer

.( Мы вернулись. Все круто!!! )
cr
cr


c Теперь посмотрим, что можно сделать в плане организации меток в
c программе, на тот случай, если вдруг понадобится (ну приспичит)
c сделать очень не структурную программу, или еще вариант: вы переделываете
c программу на языке BASIC, а там одни переходы, а вам лениво вдумываться.
c Организация такая:


region template 0 ,	-- временная переменная, счетчик


: test-label
	label: *	-- таким образом инициализируется таблица меток
			-- дело в том, что вдруг вам захочется организовать
			-- безусловный переход из одного слова в другое
			-- (если бы ВИРТ был R.I.P, то он бы перевернулся
			-- и не один раз), тогда автоматическая инициализация
			-- таблицы при начале каждого определения сделала
			-- бы невозможным такие выкрутасы(во первых), а так-
			-- же при создании имени каждого слова на енту
			-- инициализацию требовалдлось бы много времени.
			-- По этим причинам инициализация ручная.
	template 0!

label:	A		-- Так задается метка "A", дело в том что
			-- метки состоят из одной буквы и начинаются
			-- с буквы "A"-латинская,  так далее, пока
			-- не заедем на стек данных, но можно гарантировать
			-- что для заглавных английских букв места хватит

	-- Этот пример безсмысленен в смысле логики или наличия
	-- хоть какогото полезного действия, он просто показывает
	-- как надо практически оформлять работу с метками.



	template dup 1+! @ select
	1 case branch label B ecase	-- "branch label A" - переход
	2 case branch label C ecase
	3 case branch label D ecase
	4 10 diap branch label E ecase
	branch label F
	eselect

label: B
	." Каждый охотник "
	branch label A
label: C
	." желает знать "
	branch label A
label: D
	." где сидит "
	branch label A
label: E
	." фазан " cr
	branch label A

label: F
	."             Народная мудрость."cr
;


.( Начали показ работы меток)
test-label
.( Закончили показ работы меток)

cr cr
forget test-label



c Каждому программеру интересно, а как же ввести кнопочку с клавиатуры.
c Да, есть и сдесь такая возможность, и не одна.
c Во первых можно сделать это через запрос к системе (.TTYIN) - 
c это делает слово "key". Во вторых это можно сделать обращением
c к регистрам клавиатуры. Вот этот вариант мы и посмотрим.

c 	clt	- 	Запретить прерывания от клавиатуры
c 	stt	-	Разрешить прерывания от клавиатуры
c 	ttyin	-c	Ввести символ с ожиданием нажатия
c 	ttinr	-c	Ввести символ без ожидания нажатия
c			если нет нажатия, то возвращается 0


: test-keyboard
	clt		-- Дело в том, что ttyin & ttinr
			-- работают только когда прерывания от
			-- клавиатуры запрещены, а системный ввод
			-- с клавиатуры работает тогда, когда они
			-- разрешены.
	." Жмите кнопки. Конец ввода - символ ';'" cr
	begin
		ttyin dup
		select
		bl c" z diap dup emit ecase
		c" * emit
		eselect
	c" ; =
	until	
	stt		-- Разрешаем прерывания от клавиатуры
;


.( Показываем работу клавиатуры)
test-keyboard


cr cr cr cr cr 

.( Все ... )

                                                                                                                                                                               